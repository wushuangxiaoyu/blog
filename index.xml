<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>木屐帽子 on 木屐帽子</title>
    <link>https://wushuangxiaoyu.github.io/blog/</link>
    <description>Recent content in 木屐帽子 on 木屐帽子</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-ch</language>
    <lastBuildDate>Sun, 15 Sep 2019 21:16:25 +0800</lastBuildDate>
    <atom:link href="/blog/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>HMAC-SHA1接口校验</title>
      <link>https://wushuangxiaoyu.github.io/blog/posts/hmac-sha1/</link>
      <pubDate>Sun, 15 Sep 2019 21:16:25 +0800</pubDate>
      
      <guid>https://wushuangxiaoyu.github.io/blog/posts/hmac-sha1/</guid>
      <description>

&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;对于面向客户端的api接口，可以通过HMAC算法对Request生成摘要信息，请求时携带摘要信息，服务端进行校验的方式防止请求被篡改等中间攻击，也对防爬起到一定作用。&lt;/p&gt;

&lt;h2 id=&#34;hmac-sha1&#34;&gt;HMAC-SHA1&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;HMAC是密钥相关的哈希运算消息认证码(Hash-based Message Authentication Code),HMAC运算利用哈希算法(HMAC-SHA1就是使用SHA1哈希算法)，以一个密钥和一个消息为输入，生产一个消息摘要作为输出。消息鉴别码实现鉴别的原理是:
用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC,并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。&lt;/p&gt;

&lt;p&gt;摘要信息类似这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-HTML&#34;&gt;&amp;quot;Authorization: AWS &amp;quot; + AWSAccessKeyId + &amp;quot;:&amp;quot;  + base64(hmac-sha1(VERB + &amp;quot;\n&amp;quot;
                   + CONTENT-MD5 + &amp;quot;\n&amp;quot;
                   + CONTENT-TYPE + &amp;quot;\n&amp;quot;
                   + DATE + &amp;quot;\n&amp;quot;
                   + CanonicalizedAmzHeaders + &amp;quot;\n&amp;quot;
                   + CanonicalizedResource))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;我们可以自由规定需要散列的字段，比如时间戳，一些头信息，原子参数等&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;代码实现如下(Go语言):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-GO&#34;&gt;func main() {
	accessSecret := &amp;quot;dasas&amp;quot;
	url := &amp;quot;www.baidu.com&amp;quot;
	request := http.Request{}
	// 需要签名的字段
	stringToSign := request.Method + &amp;quot;\n&amp;quot; +
		&amp;quot;\n&amp;quot; +
		request.Header.Get(&amp;quot;Content-type&amp;quot;) + &amp;quot;\n&amp;quot; +
		url + &amp;quot;\n&amp;quot;
	signature := sha1base64(stringToSign, accessSecret)
	authorization := fmt.Sprintf(&amp;quot;Authorization: AWS: %s&amp;quot;, signature)
	fmt.Println(authorization)
}

func sha1base64(strToSign string, secret string) string {
	key := []byte(secret)
	h := hmac.New(sha1.New, key)
	h.Write([]byte(strToSign))
	return string(base64.StdEncoding.EncodeToString(h.Sum(nil)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;HMAC-SHA1作为一种类似对称加密的方式，不可避免的需要在两端存储秘钥。相关讨论参见:&lt;a href=&#34;https://stackoverflow.com/questions/5487757/using-hmac-sha1-for-api-authentication-how-to-store-the-client-password-secure&#34;&gt;Using HMAC-SHA1 for API authentication - how to store the client password securely?&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-参考文档&#34;&gt;五. 参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.wolfe.id.au/2012/10/20/what-is-hmac-authentication-and-why-is-it-useful/&#34;&gt;What is HMAC Authentication and why is it useful?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Antigen:让zsh更好用</title>
      <link>https://wushuangxiaoyu.github.io/blog/posts/antigen/</link>
      <pubDate>Sun, 18 Aug 2019 21:29:25 +0800</pubDate>
      
      <guid>https://wushuangxiaoyu.github.io/blog/posts/antigen/</guid>
      <description>

&lt;h1 id=&#34;antigen&#34;&gt;Antigen&lt;/h1&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;使用&lt;a href=&#34;https://github.com/zsh-users/antigen&#34;&gt;Antigen&lt;/a&gt; 让你的zsh更好用！&lt;/p&gt;

&lt;h1 id=&#34;配置&#34;&gt;配置：&lt;/h1&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;保存一下我的配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;antigen bundle git
antigen bundle github
antigen bundle git-flow
#antigen bundle brew
antigen bundle heroku
antigen bundle pip
antigen bundle lein
antigen bundle iterm2
#antigen bundle man
antigen bundle osx
#antigen bundle command-not-found

# Syntax highlighting bundle.
antigen bundle zsh-users/zsh-syntax-highlighting
#antigen bundle zsh-users/zsh-autosuggestions
#antigen bundle zsh-users/zsh-completions

#antigen bundle soimort/translate-shell
# Load the theme.
antigen theme robbyrussell
# Tell Antigen that you&#39;re done.
antigen apply

export ZSH=&amp;quot;$HOME/.oh-my-zsh&amp;quot;
[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . $(brew --prefix)/etc/profile.d/autojump.sh

source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>【Go】interface{}和反射</title>
      <link>https://wushuangxiaoyu.github.io/blog/posts/go_interfaceandreflect/</link>
      <pubDate>Sun, 21 Jul 2019 21:32:21 +0800</pubDate>
      
      <guid>https://wushuangxiaoyu.github.io/blog/posts/go_interfaceandreflect/</guid>
      <description>

&lt;h2 id=&#34;一-引言&#34;&gt;一. 引言&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这几天在撸代码的时候，频繁用到了interface{}和反射，发现自己对Go reflect包还不是很熟悉，特地学习了一下Go反射的相关使用方法和机制，特梳理总结出来，方便日后回顾。&lt;/p&gt;

&lt;h2 id=&#34;二-什么是反射&#34;&gt;二. 什么是反射&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;来看一下反射的定义：反射是一种能力，通过反射，程序可以在程序运行时动态的获取对象信息，分析类的能力以便于自我控制和调整。在我理解：反射机制最关键的地方在于，程序可以在&lt;strong&gt;运行状态&lt;/strong&gt;的自审和探知🐶。&lt;/p&gt;

&lt;h2 id=&#34;三-go的类型系统&#34;&gt;三. Go的类型系统&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;既然反射机制很重要的一点就是运行时对类型的审查，那么在弄懂Go的反射机制之前，应该先了解Go的类型系统&lt;/p&gt;

&lt;h3 id=&#34;3-1面向对象&#34;&gt;3.1面向对象？&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;在&lt;a href=&#34;https://golang.google.cn/doc/faq#Is_Go_an_object-oriented_language&#34;&gt;Is Go an object-oriented language?&lt;/a&gt;中有官方给出的回答如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes).
Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;可以看出，Go并不完全支持&amp;rdquo;面向对象&amp;rdquo;，比如Go中可以使用继承，但是却没有像C++或者Java那样清晰的层次结构。这会在实际编码过程中遇到很多的坑，最典型的就是并不能用父类型直接接收子类型对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type Person struct {
	Name string
}

type Teacher struct {
	Person
}

func PrintName(p Person){
	fmt.Println(p.Name)
}

func main() {
	t := Teacher{}
	t.Name = &amp;quot;aaa&amp;quot;
	PrintName(t)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;上面的代码是不能编译通过的，因为Go中并没有Java中的Is-A的概念！所以得使用interface{}来接收 或者 使用一个定义了PrintName()这个方法的接口去接收，而Person类和Teacher类都去实现PrintName()方法。&lt;/p&gt;

&lt;h3 id=&#34;3-2-interface&#34;&gt;3.2 interface{}&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;在使用interface{}的过程中，遇到了特别多的坑，并不能把interface{}单纯的和Java中的Object类类比。
&amp;emsp;&amp;emsp;interface{}在Go中表示一个空的接口，Go中接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。&lt;strong&gt;如果一个类型实现了一个 interface 中所有方法，我们说类型实现了该 interface&lt;/strong&gt;，&lt;strong&gt;所以所有类型都实现了它。它可以接收任何类型！&lt;/strong&gt;
&amp;emsp;&amp;emsp;interface在Go底层，被表示为一个值和值对应的类型的集合体。在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil:
&lt;img src=&#34;https://wushuangxiaoyu.github.io/blog/blog/images/blog/interface&amp;amp;reflect/interface.png&#34; alt=&#34;Image&#34; /&gt;
&amp;emsp;&amp;emsp;一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】&lt;/p&gt;

&lt;h2 id=&#34;四-reflect包&#34;&gt;四.reflect包&lt;/h2&gt;

&lt;h3 id=&#34;4-1-typeof-和-valueof&#34;&gt;4.1 TypeOf 和 ValueOf&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;reflect.TypeOf 接受任意的 interface{} 类型, 并以reflect.Type形式返回其&lt;strong&gt;动态类型&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;t := reflect.TypeOf(3)  // a reflect.Type
fmt.Println(t.String()) // &amp;quot;int&amp;quot;
fmt.Println(t)          // &amp;quot;int&amp;quot;

var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) // &amp;quot;*os.File&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。&lt;/p&gt;

&lt;h3 id=&#34;4-2-对value强制转换&#34;&gt;4.2 对Value强制转换&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func main() {
	var num float64 = 1.2345

	pointer := reflect.ValueOf(&amp;amp;num)
	value := reflect.ValueOf(num)

	// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic
	// Golang 对类型要求非常严格，类型一定要完全符合
	// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic
	convertPointer := pointer.Interface().(*float64)
	convertValue := value.Interface().(float64)

	fmt.Println(convertPointer) //0xc42000e238
	fmt.Println(convertValue)   //1.2345
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-3-遍历field&#34;&gt;4.3 遍历Field&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type User struct {
	Name string
	Age  int
}

func (this User) GetName() {
	fmt.Println(this.Name)
}

func (this *User) GetAge() {
	fmt.Println(this.Age)
}

func main() {
	user := User{Name: &amp;quot;老王&amp;quot;, Age: 66}

	TestFieldAndMethod(user)
}

func TestFieldAndMethod(ob interface{}) {
	getType := reflect.TypeOf(ob)
	fmt.Println(&amp;quot;Type is :&amp;quot;, getType.Name())

	getValue := reflect.ValueOf(ob)
	fmt.Println(&amp;quot;Values is:&amp;quot;, getValue)

	for i := 0; i &amp;lt; getType.NumField(); i++ {
		field := getType.Field(i)
		value := getValue.Field(i).Interface()
		fmt.Printf(&amp;quot;%s: %v = %v\n&amp;quot;, field.Name, field.Type, value)
	}
	
	for i := 0; i &amp;lt; getType.NumMethod(); i++ {
		m := getType.Method(i)
		fmt.Printf(&amp;quot;%s: %v\n&amp;quot;, m.Name, m.Type)
		m2 := getValue.Method(i)
		args := make([]reflect.Value, 0)
		//要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理
		m2.Call(args)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###4.4 通过Value修改原来的值&lt;/p&gt;

&lt;h2 id=&#34;五-性能问题&#34;&gt;五.性能问题&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;Go的反射很慢，这个和它的api设计有关。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt; type_ := reflect.ValueOf(obj)
 fieldValue := type_.FieldByName(&amp;quot;hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这里取出来的fielValue类型是reflect.Value，它是一个具体的值，而不是一个可复用的反射对象。这样每次反射都需要malloc这个reflect.Value结构体。
&amp;emsp;&amp;emsp;在Go中基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。&lt;/p&gt;

&lt;h2 id=&#34;六-参考文档&#34;&gt;六.参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kancloud.cn/wizardforcel/gopl-zh&#34;&gt;Go语言圣经&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5a75a4fb5188257a82110544&#34;&gt;Golang的反射reflect深入理解和示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>OAuth 2.0和第三方登录</title>
      <link>https://wushuangxiaoyu.github.io/blog/posts/oauth-2.0%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</link>
      <pubDate>Thu, 18 Apr 2019 19:49:29 +0800</pubDate>
      
      <guid>https://wushuangxiaoyu.github.io/blog/posts/oauth-2.0%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</guid>
      <description>

&lt;h2 id=&#34;一-什么是oauth2-0&#34;&gt;一. 什么是OAuth2.0&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&#34;https://oauth.net/2/&#34;&gt;OAuth&lt;/a&gt;是一种开放标准的授权协议或框架，为应用程序提供 “secure designated access” 的能力，在全世界得到广泛应用。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;举个例子，你授权京东可以访问你微信的个人资料等信息，而无需提供京东你的微信密码。这可以最大限度地降低风险：如果京东遭遇破坏，你的微信密码仍然是安全的。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;OAuth不共享密码数据，而是使用授权令牌来证明消费者和服务提供商之间的身份。OAuth是一种身份验证协议，允许你代表你批准与另一个应用程序交互的应用程序，而不会泄露你的密码。&lt;/p&gt;

&lt;h2 id=&#34;二-oauth应用场景&#34;&gt;二. OAuth应用场景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第三方登录授权服务（微信，FaceBook等都支持OAuth2.0）&lt;/li&gt;
&lt;li&gt;与第三方应用的资源请求或交互&lt;/li&gt;
&lt;li&gt;相同公司的不同应用信息共享（uid 相同,openid 不同）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;三-oauth2-0-流程&#34;&gt;三. OAuth2.0 流程&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;OAuth2.0有多种模式，这里只说明授权码模式，具体可参考&lt;a href=&#34;https://oauth.net/2/grant-types/&#34;&gt;OAuth 2.0 Grant Types&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;授权码模式&#34;&gt;授权码模式&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;授权代码授权类型由Web和移动应用程序使用。它与大多数其他授权类型不同，首先要求应用程序启动浏览器以开始流程。在较高级别，流程包括以下步骤：
- 应用程序打开浏览器或拉起应用以将用户发送到OAuth服务器
- 用户看到授权提示并批准应用程序的请求
- 使用查询字符串中的授权代码将用户重定向回应用程序
- 应用程序通过授权代码交换访问令牌&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&lt;img src=&#34;https://wushuangxiaoyu.github.io/blog/blog/images/blog/oauth/OAuth_oauth_code.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;四-应用-第三方登录&#34;&gt;四. 应用：第三方登录&lt;/h2&gt;

&lt;h3 id=&#34;基本流程&#34;&gt;基本流程&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;了解了OAuth2.0的流程，第三方登录流程就很简单了，流程图如下所示：&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&lt;img src=&#34;https://wushuangxiaoyu.github.io/blog/blog/images/blog/oauth/OAuth_oauth_login2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;遇到的问题&#34;&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;在 Facebook 的第三方登录提供的接口中，并没有看到获取code的方法，授权成功后就可以直接获取accessToken了&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp; 在stackoverflow看了一下，不只我一个遇到这个问题：&lt;a href=&#34;https://stackoverflow.com/questions/25185219/facebook-login-via-android-sdk-is-it-possible-to-get-the-code-token-without-e&#34;&gt;Facebook login via Android SDK: Is it possible to get the “code” token without exchanging it for an access token?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;也许是因为fb依赖的自己的sdk，获取code的操作在内部已经自动完成了，这样应该也可以，或者说更安全一些？&lt;/p&gt;

&lt;h2 id=&#34;五-参考文档&#34;&gt;五. 参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;amp;t=resource/res_list&amp;amp;verify=1&amp;amp;id=open1419317851&amp;amp;token=&amp;amp;lang=zh_CN&#34;&gt;微信开放平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.facebook.com/docs/facebook-login/permissions/v2.2?locale=zh_CN&#34;&gt;权限参考文档 — Facebook 登录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://oauth.net/2/&#34;&gt;OAuth 2.0 — OAuth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&#34;&gt;理解OAuth 2.0 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>hello-world</title>
      <link>https://wushuangxiaoyu.github.io/blog/posts/hello-world/</link>
      <pubDate>Mon, 25 Mar 2019 18:51:14 +0800</pubDate>
      
      <guid>https://wushuangxiaoyu.github.io/blog/posts/hello-world/</guid>
      <description>&lt;p&gt;hello world&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://wushuangxiaoyu.github.io/blog/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://wushuangxiaoyu.github.io/blog/about/</guid>
      <description>&lt;p&gt;大学即将毕业，即将迎来新的人生旅途，趁着这两天没有工作，搭个自己的博客，记录一下自己的学习和思考，也算是给自己一些鼓励吧.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>